---
title: Constraining data size with TypeScript
tags: [typescript]
date: 2023-06-16
draft: true
---

Ever wondered how to require an array to be non-empty or of a specific length
at the type-level? In this post, I want to explore how to this with TypeScript.

These types aren't often needed in practice, but I think learning about it can
improve our understanding of TypeScript.

# Arrays

## Empty arrays

The empty array seems to be the easiest:

```tsx twoslash
type EmptyArray = []

// @errors: 2322
const nonEmptyArray: EmptyArray = [1, 2, 3]
const emptyArray: EmptyArray = []
```

It even prevents us from mutating the array:

```tsx twoslash
// @errors: 2345
type EmptyArray = []

const emptyArray: EmptyArray = []
emptyArray.push(1)
```

I honestly thought this would be more complicated, but apparently it isn't.

## Non-empty arrays

Let's try to create a type for non-empty arrays now.

The trick is to use [rest
elements](https://devblogs.microsoft.com/typescript/announcing-typescript-4-2-beta/#leading-middle-rest-elements-in-tuple-types)
in tuple types -- which are meant to model arrays of specific lengths or types.

Since we don't care about the specific type, we'll just use a tuple of
`unknown`. The array should have at least one `unknown` type and the "rest" can
be any number of `unknown`s:

```tsx twoslash
type NonEmptyArray = [unknown, ...unknown[]]

// @errors: 2322
const nonEmptyArray: NonEmptyArray = [1, 2, 3]
const emptyArray: NonEmptyArray = []
```

# Strings

## Empty strings

Empty string are as easy to represent as empty arrays:

```tsx twoslash
// @errors: 2322 2588
type EmptyString = ''

const nonEmptyString: EmptyString = 'foo'
const emptyString: EmptyString = ''

emptyString += 'bar'
```

## Non-empty strings

Non-empty strings are way trickier. Unfortunately, I don't think it's possible
to do it with current TypeScript features.

I initially thought the solution would involve template literal types, which is
correct... Except it's totally impractical and inelegant:

```tsx twoslash
// @errors: 2322
type Character = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'

type NonEmptyString = `${Character}${string}`

const nonEmptyString: NonEmptyString = 'foo'
const emptyString: NonEmptyString = ''
```

The other, more practical, solution is to use a generic conditional type which
will return `never` when the string is empty:

```tsx twoslash
// @errors: 2322
type NonEmptyString<T extends string = string> = T extends '' ? never : T

const nonEmptyString: NonEmptyString<'foo'> = 'foo'
const emptyString: NonEmptyString<''> = ''
```

This type is inconvenient to use (due to repetition), it's less bad if we're
using it in a function, but the error message isn't very helpful:

```tsx twoslash
// @errors: 2345
type NonEmptyString<T extends string = string> = T extends '' ? never : T

function dontPassAnEmptyString<T extends string = string>(
  str: NonEmptyString<T>
) {
  return str
}

const nonEmptyString = dontPassAnEmptyString('foo')
const emptyString = dontPassAnEmptyString('')
```
